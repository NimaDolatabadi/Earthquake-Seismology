#!/bin/csh -f

setenv GMTHOME /prog1/gmt
#printenv | grep GMTHOME

###########################  last changed by tvedt aug 2004 #############
# check syntax of program
if ( $#argv != 1 ) then
  printf "\n\nTo start program, type in the following command:\ngmtxy nameofinputfile.out\n\n"
  exit 0
endif
###########################
# check OS for compatibility 
set sys = ` uname `

###########################################
# check for GMT installation / specify path
set checkgmt = ` printenv | grep GMTHOME | awk -F'=' '{print $2}' `
if ( $checkgmt == "" ) then
printf "Could not find environment variable GMTHOME\n"
printf "Please specify path to your GMT installation (e.g. /usr/local/GMT3.3.6):\n"
set checkgmt = $<
setenv GMTHOME $checkgmt
endif

echo $GMTHOME

#####################################
# be silent or loud in console output
set silent = 1

########################################################
# check for color availability in system (X11-specific?)
set use_showrgb = 0
set testrgb = ` which showrgb | grep showrgb | awk '{print NF}' `
if ( $testrgb == "1" ) then
set use_showrgb = 1
endif
####################################################################
# in case there is now such thing as showrgb, we need to localize
# the rgb.txt file by ourselves - system specific (MS Windows ?? - no idea)
if ( $use_showrgb != "1" ) then
switch ( $sys )
case "Linux":
set rgbfile = ` find /usr/X11 -name rgb.txt -print | grep rgb | head -1 `
breaksw
case "SunOS":
set rgbfile = ` find /usr/openwin -name rgb.txt -print | grep rgb | head -1 `
breaksw
endsw
endif
set avfonts = "Helvetica Helvetica-Bold Helvetica-Oblique Helvetica-BoldOblique Times-Roman Times-Bold Times-Italic Times-BoldItalic Courier Courier-Bold Courier-Oblique Courier-BoldOblique Symbol AvantGarde-Book AvantGarde-BookOblique AvantGarde-Demi AvantGarde-DemiOblique Bookman-Demi Bookman-DemiItalic Bookman-Light Bookman-LightItalic Helvetica-Narrow Helvetica-Narrow-Bold Helvetica-Narrow-Oblique Helvetica-Narrow-BoldOblique NewCenturySchlbk-Roman NewCenturySchlbk-Italic NewCenturySchlbk-Bold NewCenturySchlbk-BoldItalic Palatino-Roman Palatino-Italic Palatino-Bold Palatino-BoldItalic ZapfChancery-MediumItalic ZapfDingbats Ryumin-Light-EUC-H Ryumin-Light-EUC-V GothicBBB-Medium-EUC-H GothicBBB-Medium-EUC-V"

##############################################################
# process ascii input file to get all necessary information  #
# for the plotting                                           #
##############################################################

##################################
# look for keywords:
# Also, check if the script is started in a proper manner

set ofile = ` grep OFILENAME $1 | awk '{print $3}' `
set ntraces = ` grep NTRACES $1 | awk '{print $3}' `
if ( $ofile == "" ) then
	printf "No output tile indicated. Set parameter OFILENAME in input file,\nor check input filename.\n\nProgram stops.\n\nThe program manual can be found in the SEISAN manual, \nor at the INF directory, named gmtxy.doc\n" 
	exit 0
endif

##################################
# what and how to plot in title
set maintitle = ` grep MAINTITLE $1 | awk '{for(i=3;i<=NF;i++) {printf(" %s",$i)}}' `
set font = ` grep MAIN_FONT_TYPE $1 | awk '{print $3}' `
if ( $font == "" ) then
set font = "Times-Roman"
endif
set hdrfontsize = ` grep MAIN_FONT_SIZE $1 | awk '{print $3}' `
if ( $hdrfontsize == "" ) then
set hdrfontsize = 16
endif
set labelfontsize = ` echo $hdrfontsize | awk '{print $1-2}' `
set anotfontsize = ` echo $hdrfontsize | awk '{print $1-4}' `
###########################################
# least font size should not be less than 10
while ( $anotfontsize < 10 )
@ hdrfontsize++
@ labelfontsize++
@ anotfontsize++
end
###########################################
# is a legend to be plotted to the right?
set legend = ` grep LEGEND $1 | awk '{print $3}' `
if ( $legend == "" ) then
	set legend = 0
endif




set xmin = ` grep MINX $1 | awk '{printf("%lf\n",$3)}' | sort -n | head -1 `
set ymin = ` grep MINY $1 | awk '{printf("%lf\n",$3)}' | sort -n | head -1 `
set xmax = ` grep MAXX $1 | awk '{printf("%lf\n",$3)}' | sort -n | tail -1 `
set ymax = ` grep MAXY $1 | awk '{printf("%lf\n",$3)}' | sort -n | tail -1 `

###############################################################
# A loop to make certain exceptions when plotting histograms. #
# A known bug is that it only works for the first dataset -   #
# i.e. histograms should be presented as the first dataset!!  #
###############################################################
set b = 1

while ( $b <= $ntraces )

set currsymbol = ` grep TRACESYMBOL $1 | awk '{print $3}' | awk 'NR=='$b' {print $1;exit}' `
set barw = ` grep BAR_WIDTH $1 | awk '{print $3}'  `
# | awk 'NR=='$b' {print $1;exit}' `

if ( $currsymbol == "b" ) then
	set xmin = ` echo $xmin $barw | awk '{printf($1-($2)/2)}' `
	set xmax = ` echo $xmax $barw | awk '{printf($1+($2)/2)}' `
	printf "\nHistogram plotting - xmin and xmax adjusted.\nNew values:\n"
	echo xmin = $xmin , xmax = $xmax
	set legend = 0
endif


@ b++



if ( $legend == "" ) then
set legend = 0
endif
##########################################
# first guess for a reasonable fontsize plotting the legend
if ( $legend == "1" ) then
set legendfontsize = $labelfontsize
endif
if ( $legend == "1" ) then
	set legendfontsize = $labelfontsize
endif

##########################################
# what to plot as axis-labels
set xtitle = ` grep XTITLE $1 | awk '{for(i=3;i<=NF;i++) {printf(" %s",$i)}}' `
set ytitle = ` grep YTITLE $1 | awk '{for(i=3;i<=NF;i++) {printf(" %s",$i)}}' `
###########################################
# size of plot
set xsize = ` grep XSIZE $1 | awk '{printf($3*1)}' `
set ysize = ` grep YSIZE $1 | awk '{print $3}' `
#if ( $xsize == 12.00 ) then
#	set seis = ` echo $xsize | awk '{printf($1/2)}' `
#else 
#	set seis = ` echo $xsize | awk '{printf($1*2)}' `
#	set xsize = ` echo $xsize | awk '{printf($1-1)}' `
#endif
#echo $seis
###########################################
# axis - types lin or log ?
set xlog = ` grep XLOG $1 | awk '{print $3}' `
set ylog = ` grep YLOG $1 | awk '{print $3}' `

###########################################
# gridlines - with or without ?
set xgrid = ` grep GRID_X $1 | awk '{print $3}' `
set ygrid = ` grep GRID_Y $1 | awk '{print $3}' `

#################################
# check for region to plot
set xrange = $xmin"/"$xmax
set yrange = $ymin"/"$ymax
set region = $xrange"/"$yrange
set xdiff = ` echo $xmin $xmax | awk '{printf("%lf",$2-$1)}' `
set ydiff = ` echo $ymin $ymax | awk '{printf("%lf",$2-$1)}' `
#echo $xdiff $ydiff

#set verbose

###########################################
# plot some information on console if desired
if ( $silent != "0" ) then
	printf "\n############################################\n\n"
	printf "GMT script executed on OS: %s\n" $sys
	printf "PS-output will be written to file %s\n" $ofile
	printf "Number of traces to process is %d\n" $ntraces
	printf "Plotsize will be %f x %f cm + titles\n" $xsize $ysize
	printf "Overall plotregion is %s (xmin/xmax/ymin/ymax)\n" $region
	printf "Desired axis types are X %d and Y %d (1=log/0=lin)\n" $xlog $ylog
	printf "\n############################################\n\n"
endif

###############################################
# adjust legendfontsize here....
if ( $legend == 1 ) then
	set legendfontsize = ` echo $ntraces $ysize | awk 'BEGIN {fs='$legendfontsize'} {while($1*fs*2.54/72>0.75*$2) {fs-=1;if(fs<=10) {break}}} END {print fs}' `
endif
#############################################################################
# check for lin or log axes and set GMT options and ticks 
# according to required axes-type - nasty business!!
# need some preliminaries here ...

#####################################################
# fontsize in points is defined for 72 dpi resolution
# calculate here the size of a letter in cm (height)
set fy = `echo $anotfontsize | awk '{print $1*2.54/72}' `
 
#####################################################
# fontsize in points is defined for 72 dpi resolution
# calculate here the size of the letter width in cm
# this is just approximate - but I don't want to dig out
# details of font design and definitions .......
set fx = `echo $anotfontsize | awk '{print $1*2.54/72*0.8}' `
if ( $xlog == "1" ) then
	if ( $ylog == "1" ) then
		set proj = ${xsize}"l/"${ysize}"l"
			if ( $xgrid == "1" ) then
		  		set xtick = a2f3g2
			else
		       	set xtick = a2f3
			endif
			if ( $ygrid == "1" ) then
		    	set ytick = a2f3g2
			else 
        		set ytick = a2f3
			endif
  	else
    		set proj = ${xsize}"l/"${ysize}
		if ( $xgrid == "1" ) then
			set xtick = a2f3g2
		else
			set xtick = a2f3
		endif

    	######################################################
    	# give a first estimate which annotation interval fits to the
    	# data range to be plotted
    		set anot = ` echo $ydiff | awk 'BEGIN {div=100000000000.} {while($1%div==$1) {div/=10.}} END {print div}' `
    	######################################################
    	# now adjust the annotation interval in such way that the total text 
    	# size for the annotations does not exceed 65% of axis length
    		set anot = ` echo $ydiff $anot $fy $ysize $ymin $ymax | awk 'BEGIN {anot='$anot'} {while((($6-($6%anot))-($5-($5%anot)))/anot*$3>0.65*$4) {anot*=2}} END {print anot}' `
    		set nanot = ` echo $ymin $ymax $anot | awk '{print ($2-($2%$3)-$1+($1%$3))/$3}' `
   	#######################################################
    	# check again here - need minimum 2 annotations to be able to decode 
    	# the data range plotted - if there are less than 2 annotations, then
    	# adjust the annotation interval to have at least 2 annotated ticks 
    		set anot2 = ` echo $ymin $ymax $anot | awk 'BEGIN {anot='$anot'} {while(($2-($2%anot)-$1+($1%anot))/anot<2) {anot/=2}} END {print anot}' `
    		set nanot2 = ` echo $ymin $ymax $anot2 | awk '{print ($2-($2%$3)-$1+($1%$3))/$3}' `
    	#######################################################
    	# if annotation interval has been adjusted in the previous check
    	# the annotated text size will exceed 65% of the axis length - 
    	# relax the length contraint to 75% - if this doesn't help, 
    	# reduce font size to save space - minimum allowed font size is 10 points!
    		if ( $anot != $anot2 ) then
      		# echo "adjusting fontsize now..."
      			set finanoty = $anot2
      			set nanot3 = ` echo $ymin $ymax $anot2 | awk '{print (($2-($2%$3)-$1+($1%$3))/$3)}' `
      			set fynew = ` echo $nanot3 $finanoty $anotfontsize $ysize | awk 'BEGIN {fs='$anotfontsize'} {while($1*fs*2.54/72>0.75*$4) {fs-=1;if(fs<=10) {break}}} END {print fs}' `
    		else
      			set finanoty = $anot
      			set nanot3 = ` echo $ymin $ymax $anot | awk '{print (($2-($2%$3)-$1+($1%$3))/$3)}' `
      			set fynew = $anotfontsize
    		endif
    	#####################################################
    	# now map the result to variable t
    		set t = ` echo $finanoty | awk '{print $1, $1/5}' `
    		set anotfontsize = $fynew 
    	#####################################################
    	# assign the ticks finally in GMT syntax

		if ( $ygrid == "1" ) then 
	    		set ytick = a$t[1]f$t[2]g$t[1]
		else
			set ytick = a$t[1]f$t[2]
		endif
  	endif
else
  	if ( $ylog == "1" ) then

    		set proj = ${xsize}/${ysize}l
    		######################################################
    		# give a first estimate which annotation interval fits to the
    		# data range to be plotted
    		set anot = ` echo $xdiff | awk 'BEGIN {div=100000000000.} {while($1%div==$1) {div/=10.}} END {print div}' `
    		######################################################
    		# now adjust the annotation interval in such way that the total text 
    		# size for the annotations does not exceed 65% of axis length
    		set anot = ` echo $xdiff $anot $fx $xsize $xmin $xmax | awk 'BEGIN {anot='$anot'} {while((($6-($6%anot))-($5-($5%anot)))/anot*length(anot)*$3>0.65*$4) {anot*=2}} END {print anot}' `
    		set nanot = ` echo $xmin $xmax $anot | awk '{print ($2-($2%$3)-$1+($1%$3))/$3}' `
    		#######################################################
    		# check again here - need minimum 2 annotations to be able to decode 
    		# the data range plotted - if there are less than 2 annotations, then
    		# adjust the annotation interval to have at least 2 annotated ticks 
    		set anot2 = ` echo $xmin $xmax $anot | awk 'BEGIN {anot='$anot'} {while(($2-($2%anot)-$1+($1%anot))/anot<2) {anot/=2}} END {print anot}' `
    		set nanot2 = ` echo $xmin $xmax $anot2 | awk '{print ($2-($2%$3)-$1+($1%$3))/$3}' `
    		#######################################################
    		# if annotation interval has been adjusted in the previous check the 
    		# annotated text size will now exceed 65% of the axis length - 
    		# relax now the length contraint to 75% - if this doesn't help, 
    		# reduce font size to save space - minimum allowed font size is 10 points!
    		if ( $anot != $anot2 ) then
    	  	# echo "adjusting fontsize now..."
      			set finanotx = $anot2
      			set nanot3 = ` echo $xmin $xmax $anot2 | awk '{print (($2-($2%$3)-$1+($1%$3))/$3)}' `
      			set fxnew = ` echo $nanot3 $finanotx $anotfontsize $xsize | awk 'BEGIN {fs='$anotfontsize'} {while($1*fs*0.8*2.54/72*length($2)>0.75*$4) {fs-=1;if(fs<=10) {break}}} END {print fs}' `
    		else
      			set finanotx = $anot
      			set nanot3 = ` echo $xmin $xmax $anot | awk '{print (($2-($2%$3)-$1+($1%$3))/$3)}' `
      			set fxnew = $anotfontsize
    		endif
    		#####################################################
    		# now map the result to variable t
    		set t = ` echo $finanotx | awk '{print $1, $1/5}' `
    		set anotfontsize = $fxnew
    		#####################################################
    		# assign the ticks finally in GMT syntax

		if ( $xgrid == "1" ) then
			set xtick = a$t[1]f$t[2]g$t[1]
		else
			set xtick = a$t[1]f$t[2]
		endif
    	if ( $ygrid == "1" ) then
			set ytick = a2f3g2
		else
			set ytick = a2f3
		endif

  	else

    		set proj = ${xsize}/${ysize}
    		######################################################
    		# give a first estimate which annotation interval fits to the
    		# data range to be plotted
    		set anot = ` echo $xdiff | awk 'BEGIN {div=100000000000.} {while($1%div==$1) {div/=10.}} END {print div}' `
    		######################################################
    		# now adjust the annotation interval in such way that the total text 
    		# size for the annotations does not exceed 65% of axis length
    		set anot = ` echo $xdiff $anot $fx $xsize $xmin $xmax | awk 'BEGIN {anot='$anot'} {while((($6-($6%anot))-($5-($5%anot)))/anot*length(anot)*$3>0.65*$4) {anot*=2}} END {print anot}' `
    		set nanot = ` echo $xmin $xmax $anot | awk '{print ($2-($2%$3)-$1+($1%$3))/$3}' `
    		#######################################################
    		# check again here - need minimum 2 annotations to be able to decode 
    		# the data range plotted - if there are less than 2 annotations, then
    		# adjust the annotation interval to have at least 2 annotated ticks 
    		set anot2 = ` echo $xmin $xmax $anot | awk 'BEGIN {anot='$anot'} {while(($2-($2%anot)-$1+($1%anot))/anot<2) {anot/=2}} END {print anot}' `
    		set nanot2 = ` echo $xmin $xmax $anot2 | awk '{print ($2-($2%$3)-$1+($1%$3))/$3}' `
    		#######################################################
    		# if annotation interval has been adjusted in the previous check the 
    		# annotated text size will now exceed 65% of the axis length - 
    		# relax now the length contraint to 75% - if this doesn't help, 
    		# reduce font size to save space - minimum allowed font size is 10 points!
    		if ( $anot != $anot2 ) then
      			# echo "adjusting fontsize now..."
      			set finanotx = $anot2
      			set nanot3 = ` echo $xmin $xmax $anot2 | awk '{print (($2-($2%$3)-$1+($1%$3))/$3)}' `
      			set fxnew = ` echo $nanot3 $finanotx $anotfontsize $xsize | awk 'BEGIN {fs='$anotfontsize'} {while($1*fs*0.8*2.54/72*length($2)>0.75*$4) {fs-=1;if(fs<=10) {break}}} END {print fs}' `
    		else
      			set finanotx = $anot
      			set nanot3 = ` echo $xmin $xmax $anot | awk '{print (($2-($2%$3)-$1+($1%$3))/$3)}' `
      			set fxnew = $anotfontsize
    		endif
    		#####################################################
    		# now map the result to variable t
    		set t = ` echo $finanotx | awk '{print $1, $1/5}' `
    		set anotfontsize = $fxnew
    		#####################################################
    		# assign the ticks finally in GMT syntax
	
		if ($xgrid == "1" ) then
    			set xtick = a$t[1]f$t[2]g$t[1]
		else
			set xtick = a$t[1]f$t[2]
		endif

    		######################################################
    		# give a first estimate which annotation interval fits to the
    		# data range to be plotted
    		set anot = ` echo $ydiff | awk 'BEGIN {div=100000000000.} {while($1%div==$1) {div/=10.}} END {print div}' `
    		######################################################
    		# now adjust the annotation interval in such way that the total text 
    		# size for the annotations does not exceed 65% of axis length
    		set anot = ` echo $ydiff $anot $fy $ysize $ymin $ymax | awk 'BEGIN {anot='$anot'} {while((($6-($6%anot))-($5-($5%anot)))/anot*$3>0.65*$4) {anot*=2}} END {print anot}' `
    		set nanot = ` echo $ymin $ymax $anot | awk '{print ($2-($2%$3)-$1+($1%$3))/$3}' `
    		#######################################################
    		# check again here - need minimum 2 annotations to be able to decode 
    		# the data range plotted - if there are less than 2 annotations, then
    		# adjust the annotation interval to have at least 2 annotated ticks 
    		set anot2 = ` echo $ymin $ymax $anot | awk 'BEGIN {anot='$anot'} {while(($2-($2%anot)-$1+($1%anot))/anot<2) {anot/=2}} END {print anot}' `
    		set nanot2 = ` echo $ymin $ymax $anot2 | awk '{print ($2-($2%$3)-$1+($1%$3))/$3}' `
    		#######################################################
    		# if annotation interval has been adjusted in the previous check
    		# the annotated text size will exceed 65% of the axis length - 
    		# relax the length contraint to 75% - if this doesn't help, 
    		# reduce font size to save space - minimum allowed font size is 10 points!
    		if ( $anot != $anot2 ) then
      			# echo "adjusting fontsize now..."
      			set finanoty = $anot2
      			set nanot3 = ` echo $ymin $ymax $anot2 | awk '{print (($2-($2%$3)-$1+($1%$3))/$3)}' `
      			set fynew = ` echo $nanot3 $finanoty $anotfontsize $ysize | awk 'BEGIN {fs='$anotfontsize'} {while($1*fs*2.54/72>0.75*$4) {fs-=1;if(fs<=10) {break}}} END {print fs}' `
    		else
      			set finanoty = $anot
      			set nanot3 = ` echo $ymin $ymax $anot | awk '{print (($2-($2%$3)-$1+($1%$3))/$3)}' `
      			set fynew = $anotfontsize
    		endif
    		#####################################################
    		# now map the result to variable t
    		set t = ` echo $finanoty | awk '{print $1, $1/5}' `
    		set anotfontsize = ` echo $fynew $fxnew | awk '{if($1<$2) {print $1} else {print $2}}' `
    		#####################################################
    		# assign the ticks finally in GMT syntax

		if ( $ygrid == "1" ) then
    			set ytick = a$t[1]f$t[2]g$t[1]
		else
			set ytick = a$t[1]f$t[2]
		endif
  	endif
endif
# echo $xtick $ytick $region $proj

##########################################
# now start plotting, provide a base first:
$GMTHOME/bin/gmtset MEASURE_UNIT cm DOTS_PR_INCH 300 ANOT_FONT_SIZE $anotfontsize HEADER_FONT_SIZE $hdrfontsize LABEL_FONT_SIZE $labelfontsize ANOT_FONT $font HEADER_FONT $font LABEL_FONT $font UNIX_TIME false
$GMTHOME/bin/psxy -P -JX$proj -R$region -B${xtick}:"$xtitle":/${ytick}:"$ytitle"::."$maintitle":WSne -K -X3.5 -Y2.5 << END > $ofile
END

#########################################
# now enter loop over all traces to plot
set c = 1

while ( $c <= $ntraces )
##############
# get title
set currtitle = ` grep TRACETITLE $1 | awk '{for(i=3;i<=NF;i++) {printf(" %s",$i)};printf("\n")}' | awk 'NR=='$c' {print $0;exit} ' ` 
#if ( $xsize == 17 ) then
#	set textbox = ` echo $xsize $ysize | awk '{print $1/2.5"/"$2}' `
#echo Altfor stor figur!!!
#endif




if ( $legend == 1 ) then
	set fontnr = ` echo $avfonts | awk '{for(i=1;i<=NF;i++) {if("'$font'"==$i) {print i-1;exit}}}' `
	set yoff = ` echo $c $ysize $ntraces | awk '{print $2-$2*($1-0.5)/$3}' `
	# if the size of the diagram is larger than 13, 
	# extra space is made for the legend at the right.
	# if the size is less than 13, the space for the 
	# legend equals 16 - xsize.
	if ( $xsize >= 13 ) then
		set textbox = ` echo $xsize $ysize | awk '{print $1/2.5"/"$2}' `
		set textregion = ` echo $xsize $ysize | awk '{print "0/"$1/2.5"/0/"$2}' `
	else
		set textbox = ` echo $xsize $ysize | awk '{print 16-$1"/"$2}' `
		set textregion = ` echo $xsize $ysize | awk '{print "0/"16-$1"/0/"$2}' `
	endif
endif
##############
# get color
# we allow just a single name color, not "green yellow" or something similar!!
# this reduces the number of available colors in rgb.txt from 752 to 657 - no big deal!
set currcolor = ` grep TRACECOLOR $1 | awk 'NR=='$c' {print $3;exit} ' ` 
if ( $use_showrgb == "1" ) then
	set col = ` showrgb | grep $currcolor | awk '{if(NF==4 && $4=="'$currcolor'") {print $1"/"$2"/"$3;exit}}' `
else
	set col = ` grep $currcolor $rgbfile | awk '{if(NF==4 && $4=="'$currcolor'") {print $1"/"$2"/"$3;exit}}' `
endif
if ( $col == "//" || $col == "" ) then
	set sym = ` grep TRACESYMBOL $1 | awk '{print $3}' | awk 'NR=='$c' {print $1;exit}' `
	if ( $sym == "b" ) then
		printf "\nColor %s could not be found\n" $currcolor
		printf "- fillcolor will be white\n"
		set col = "255/255/255"
	else
		printf "\nColor %s could not be found\n" $currcolor
		printf "use BLACK instead!\n"
		set col = "0/0/0"
		set currcolor = Black
	endif
endif
###############
# get line width
set currwidth = ` grep LINE_WIDTH $1 | awk '{print $3}' | awk 'NR=='$c' {print $1;exit}' `
if ( $currwidth == "" ) then
	set currwidth = 1
endif
################
# get line type
set currline = ` grep LINESTYLE $1 | awk '{print $3}' | awk 'NR=='$c' {print $1;exit}' `
switch ( $currline )
case default:
case "none":
case "":
set linetype = ""
breaksw
case "solid":
set linetype = $currwidth"/"${col}
breaksw
case "dashed":
set linetype = $currwidth"/"${col}"ta"
breaksw
case "dotted":
set linetype = $currwidth"/"${col}"to"
breaksw
endsw
#############
# get symbol
set currsymbol = ` grep TRACESYMBOL $1 | awk '{print $3}' | awk 'NR=='$c' {print $1;exit}' `
switch ( $currsymbol )
case default:
case "none":
case "":
set symbol = ""
breaksw
case "c":
case "a":
case "t":
case "d":
#case "b":
case "x":
case "p":
set symbol = ${currsymbol}
#case "b":
#set legend = 0
#set symbol = ${currsymbol}
breaksw
endsw

switch ( $currsymbol )
case "b":
set legend = 0
set symbol = ${currsymbol}
breaksw
endsw
# loop to differ between histogram and curves
# the width of the columns are also calculated, 
# based on the input value BAR_WIDTH.
# Also, the bar-width is corrected if zero is 
# given as width-value.
if ($symbol == "b" ) then
	set barw = ` grep BAR_WIDTH $1 | awk '{print $3*1}' `
	if ( $barw == 0 ) then
		set barw = 1
	echo Barwidth set to 1
	endif
	set hist = ` echo $xmax $xmin $xsize $barw | awk '{printf($3*$4)/($1-$2)}' `
	set currsymbolsize = ` echo $hist $ymin | awk  '{printf($1"/b"$2)}' | awk 'NR=='$c' {print $1;exit}' `
else
	set currsymbolsize = ` grep SYMBOL_SIZE $1 | awk '{print $3}' | awk 'NR=='$c' {print $1;exit}' `
endif
###########################################
# This is a part only used when plotting the b-value output
# The number of earthquakes (cummulative) is added, and the 
# fit line, as defined by the user when running the b-value program.

if ( silent != "0" ) then
	printf "plotting now Trace number %d\n" $c
	printf "using color %s which has been translated to %s rgb-tripel\n" $currcolor $col
	if ( $linetype != "" ) then
		printf "using linetype option in GMT as -W%s\n" $linetype
	else
		printf "using no linetype as required\n"
	endif

	if ( $symbol != "" ) then
		printf "using symbol option in GMT as -S%s%s\n" $symbol $currsymbolsize
	else
		printf "using no symbol as required\n"
	endif
endif
if ( $linetype == "" && $symbol == "" ) then
	printf "\nWARNING - neither symbol nor linetype chosen - trace %d not plotted!\n\n" $c
endif

###############################################
# prepare x,y column of this trace for plotting
set start = ` awk 'BEGIN {i=0} {if($2=="TRACETITLE") {i++};if (i=='$c') {print NR;exit}}' $1 `
if ( $c == $ntraces ) then
	set end = ` wc $1 | awk '{print $1}' `
else
	set end = ` awk 'BEGIN {i=0} {if($2=="TRACETITLE") {i++};if (i=='$c'+1) {print NR;exit}}' $1 `
endif
echo $start $end
awk 'NR>='$start' && NR<='$end' {if($1!="#" && NF!=0) {print $1, $2}}' $1 > ./.tmp.trace
####################################
# now append trace to postscript file
if ( $linetype != "" ) then
	$GMTHOME/bin/psxy -JX${proj} -R${region} -O -K -W${linetype} ./.tmp.trace -V >> $ofile
	if ( $legend == 1 ) then
		$GMTHOME/bin/psxy -JX$textbox -R$textregion -O -K -X$xsize -Y0 -W${linetype} << END >> $ofile
		1 $yoff
		2 $yoff
END
		$GMTHOME/bin/psxy -JX$textbox -R$textregion -O -K -X-$xsize -Y0 << END >> $ofile
END
	endif
endif
if ( $symbol != "" ) then
	$GMTHOME/bin/psxy -JX${proj} -R${region} -O -K -S${symbol}${currsymbolsize} -W1/0/0/0 -G$col -L$col ./.tmp.trace -V >> $ofile
	if ( $legend == 1 ) then
		$GMTHOME/bin/psxy -JX$textbox -R$textregion -O -K -X$xsize -Y0 -S${symbol}${currsymbolsize} -L$col -G$col << END >> $ofile
		1.5 $yoff
END
		$GMTHOME/bin/psxy -JX$textbox -R$textregion -O -K -X-$xsize -Y0 << END >> $ofile
END
	endif
endif
if ( $legend == 1 ) then
	$GMTHOME/bin/pstext -JX$textbox -R$textregion -O -K -X$xsize -Y0 -N << END >> $ofile
	2.5 $yoff $legendfontsize 0 $fontnr 5 $currtitle
END
	$GMTHOME/bin/psxy -JX$textbox -R$textregion -O -K -X-$xsize -Y0 << END >> $ofile
END
endif
#####################################
# remove temporary x, y file for trace
rm -f ./.tmp.trace

################
# counter
@ c++

end

# do this later
# now plot legend at right side of plot....
# $GMTHOME/bin/psxy -JX -R -O -K -S${symbol} -W${linetype} -X -Y << END >> $ofile

# now finish plotting, terminate nicely wthout forgetting the showpage c ommand
$GMTHOME/bin/psxy -JX${proj} -R${region} -O << END >> $ofile
END

echo "postscript file $ofile successfully plotted - EXIT"
echo "leave ghostscript with q command"

ps2epsi $ofile $ofile.eps

ghostview $ofile.eps
#gs $ofile
#exit
