function status = writesac(varargin)
% STATUS = WRITESAC(S); writes SAC data in structure S to SAC data files.
% STATUS has the same length as S with logical values indicating whether 
% the files are written successfully.
%
% Structure S is defined in m-file readsac.m and is usually generated by
% readsac.m. It has following fields that correspond to SAC header
% variables and data except the first field. The data type and length (for
% a character variable) of these variables must be consistent with SAC 
% definitions. Values of I-type header variables must be their alphanumeric
% names (all upper case), not corresponding integers.
%
%    FILENAME   - File name of SAC file
%    DELTA      - Data sampling interval
%    DEPMIN     - Minimum value of dependent variable
%    DEPMAX     - Maximum value of dependent variable
%    SCALE      - Multiplying factor for dependent variable
%    ODELTA     - Observed increment if different from nominal
%    B          - Beginning value of independent variable     
%    E          - Ending value of independent variable     
%    O          - Event origin time                        
%    A          - First arrival time                       
%    INTERNAL1  - First internal variable                  
%    T0         - First user-defined time picks or markers 
%    T1         - Second user-defined time picks or markers 
%    T2         - Third user-defined time picks or markers 
%    T3         - Fourth user-defined time picks or markers 
%    T4         - Fifth user-defined time picks or markers 
%    T5         - Sixth user-defined time picks or markers 
%    T6         - Seventh user-defined time picks or markers 
%    T7         - Eighth user-defined time picks or markers 
%    T8         - Ninth user-defined time picks or markers 
%    T9         - Tenth user-defined time picks or markers 
%    F          - Final or end of event time               
%    RESP0      - First instrument response parameter      
%    RESP1      - Second instrument response parameter      
%    RESP2      - Third instrument response parameter      
%    RESP3      - Fourth instrument response parameter      
%    RESP4      - Fifth instrument response parameter      
%    RESP5      - Sixth instrument response parameter      
%    RESP6      - Seventh instrument response parameter      
%    RESP7      - Eighth instrument response parameter      
%    RESP8      - Ninth instrument response parameter      
%    RESP9      - Tenth instrument response parameter      
%    STLA       - Station latitude                         
%    STLO       - Station longitude                        
%    STEL       - Station elevation                        
%    STDP       - Station depth                            
%    EVLA       - Event latitude                           
%    EVLO       - Event longitude                          
%    EVEL       - Event elevation                          
%    EVDP       - Event depth                              
%    MAG        - Event magnitude                          
%    USER0      - First user-defined variable                   
%    USER1      - Second user-defined variable                   
%    USER2      - Third user-defined variable                   
%    USER3      - Fourth user-defined variable                   
%    USER4      - Fifth user-defined variable               
%    USER5      - Sixth user-defined variable                   
%    USER6      - Seventh user-defined variable                   
%    USER7      - Eighth user-defined variable                   
%    USER8      - Ninth user-defined variable                   
%    USER9      - Tenth user-defined variable                   
%    DIST       - Station-to-event distance (km)
%    AZ         - Event-to-station azimuth (degree)
%    BAZ        - Station-to-event azimuth (degree)
%    GCARC      - Station-to-event great-circle arc length (degree)
%    INTERNAL2  - Second internal variable                              
%    INTERNAL3  - Third internal variable                              
%    DEPMEN     - Mean value of dependent variable                     
%    CMPAZ      - Component azimuth                                    
%    CMPINC     - Component incident angle                             
%    XMINIMUM   - Minimum value of X (spectral file only)              
%    XMAXIMUM   - Maximum value of X (spectral file only)              
%    YMINIMUM   - Minimum value of Y (spectral file only)              
%    YMAXIMUM   - Maximum value of Y (spectral file only)              
%    UNUSED1    - First unused variable                                
%    UNUSED2    - Second unused variable                                
%    UNUSED3    - Third unused variable                                
%    UNUSED4    - Fourth unused variable                                
%    UNUSED5    - Fifth unused variable                                
%    UNUSED6    - Sixth unused variable                                
%    UNUSED7    - Seventh unused variable                                
%    NZYEAR     - GMT year corresponding to reference time               
%    NZJDAY     - GMT julian day corresponding to reference time               
%    NZHOUR     - GMT hour corresponding to reference time               
%    NZMIN      - GMT minute corresponding to reference time               
%    NZSEC      - GMT second corresponding to reference time               
%    NZMSEC     - GMT milisecond corresponding to reference time               
%    NVHDR      - Header version, which is forced by the code to be 6 for
%                 endian check purpose
%    NORID      - Origin ID     
%    NEVID      - Event ID      
%    NPTS       - Number of data points
%    INTERNAL4  - Fourth internal variable
%    NWFID      - Waveform ID
%    NXSIZE     - Spectral length (spectral file only)
%    NYSIZE     - Spectral width (spectral file only)
%    UNUSED8    - Eighth unused variable             
%    IFTYPE     - Type of file                       
%    IDEP       - Type of dependent variable            
%    IZTYPE     - Reference-time equivalence         
%    UNUSED9    - Ninth unused variable              
%    IINST      - Type of recording instrument       
%    ISTREG     - Station geographic region          
%    IEVREG     - Event geographic region          
%    IEVTYP     - Type of event                    
%    IQUAL      - Quality of data                  
%    ISYNTH     - Synthetic data flag              
%    IMAGTYP    - Magnitude type                   
%    IMAGSRC    - Magnitude source                 
%    UNUSED10   - Tenth unused variable              
%    UNUSED11   - Eleventh unused variable              
%    UNUSED12   - Twelveth unused variable              
%    UNUSED13   - Thirteenth unused variable              
%    UNUSED14   - Fourteenth unused variable              
%    UNUSED15   - Fifteenth unused variable              
%    UNUSED16   - Sixteenth unused variable              
%    UNUSED17   - Seventeenth unused variable              
%    LEVEN      - True if data is evenly spaced    
%    LPSPOL     - True if station polarity follows left-hand rule
%    LOVROK     - True if it is ok to overwrite this file on disk
%    LCALDA     - True if DIST, AZ, BAZ and GCARC are to be calculated from 
%                 station and event coordinates
%    UNUSED18   - Eighteenth unused variable              
%    KSTNM      - Station name
%    KEVNM      - Event name
%    KHOLE      - Hole ID for nuclear test
%    KO         - Event origin time ID    
%    KA         - First arrival time ID    
%    KT0        - First user-defined time pick ID    
%    KT1        - Second user-defined time pick ID    
%    KT2        - Third user-defined time pick ID    
%    KT3        - Fourth user-defined time pick ID    
%    KT4        - Fifth user-defined time pick ID    
%    KT5        - Sixth user-defined time pick ID    
%    KT6        - Seventh user-defined time pick ID    
%    KT7        - Eighth user-defined time pick ID    
%    KT8        - Ninth user-defined time pick ID    
%    KT9        - Tenth user-defined time pick ID    
%    KF         - Final or end event time ID    
%    KUSER0     - First user-defined text string
%    KUSER1     - Second user-defined text string
%    KUSER2     - Third user-defined text string
%    KCMPNM     - Component name
%    KNETWK     - Network name
%    KDATRD     - Date data were read onto computer
%    KINST      - Generic name of recording instrument
%    DATA1      - First data block
%
% If SAC data are spectral or unevenly-spaced xy data, following fields may
% exist.
%
%    DATA2      - Second data block
%
% STATUS = WRITESAC(INDEP, DEP, FILENAME); writes evenly-spaced
% time-series, xy or spectra data to SAC data files. INDEP is either time,
% x or frequency vector/matrix/cell-array. DEP is either time series, y or 
% complete complex spectrum. STATUS = WRITESAC(X, Y, Z, FILENAME); writes
% xyz (spectrogram) data to SAC files. X and Y can only be vectors or cell
% arrays. FILENAME must be provided and it can be a single string, a
% character array with rows representing file names, or a cell array. With
% this WRITESAC format, only DELTA, B, E, NPTS, IFTYPE, NVHDR  and LEVEN
% are defined in time-series, spectral or xy SAC files. DELTA is only 
% defined for evenly-spaced, spectral and xyz data files. XMINIMUM,
% XMAXIMUM, YMINIMUM, YMAXIMUM, NXSIZE and NYSIZE are also defined in xyz
% data files. NVHDR is defined to be 6 for endian check purpose.
%
% *** As of this version, SAC does not define general xyz-type files. ***
%

% Copyright, 19, The Board of Governors of the Los Alamos National 
% Security, LLC. This software was produced under a U. S. Government
% contract (DE-AC52-06NA25396) by Los Alamos National Laboratory, which is
% operated by the Los Alamos National Security, LLC for the U. S. 
% Department of Energy. The U. S. Government is licensed to use, reproduce,
% and distribute this software. Permission is granted to the public to copy
% and use this software without charge, provided that this Notice and any
% statement of authorship are reproduced on all copies. Neither the 
% Government nor the LANS makes any warranty, express or implied, or 
% assumes any liability or responsibility for the use of this software.
%
%           Xiaoning Yang	2002, 2008, 2011

% check input
if nargin < 1
    help writesac
    return
elseif nargin == 1
    s = varargin{1};
    if ~isstruct(s)
        error(' Input must be a structure array !!!')
    end
elseif nargin == 3 || nargin == 4
    if nargin == 3
        indep = varargin{1};
        dep = varargin{2};
        filename = varargin{3};
        if ~isequal(numel(indep), numel(dep))
            error([' Independent and dependent variables should have ', ...
                'same sizes !!!'])
        end
        if iscell(indep)
            if ~iscell(dep)
                error([' Both independent and dependent variables ', ...
                    'should be cell arrays !!!'])
            end
            filename = cellstr(filename);
            nfiles = length(filename);
            s = sacstruct(nfiles);
            for i = 1:nfiles
                s(i).FILENAME = filename{i};
                s(i).B = indep{i}(1);
                s(i).E = indep{i}(end);
                s(i).NPTS = length(dep{i});
                s(i).NVHDR = 6;
                df = diff(diff(indep{i}));
                if ~any(df)
                    s(i).DELTA = diff(indep{i}(1:2));
                    s(i).LEVEN = true;
                    if isreal(dep{i})
                        s(i).IFTYPE = 'ITIME';
                        s(i).DATA1 = dep{i};
                    else
                        s(i).IFTYPE = 'IRLIM';
                        s(i).DATA1 = real(dep{i});
                        s(i).DATA2 = imag(dep{i});
                    end
                else
                    s(i).LEVEN = false;                    
                    s(i).IFTYPE = 'IXY';
                    s(i).DATA1 = dep{i};
                    s(i).DATA2 = indep{i};
                end
            end
        else
            if iscell(dep)
                error([' Both independent and dependent variables ', ...
                    'should be vectors or matrices !!!'])
            end
            if size(indep, 1) == 1
                indep = indep(:);
                dep = dep(:);
            end
            filename = char(filename);
            nfiles = size(filename, 1);
            s = sacstruct(nfiles);
            for i = 1:nfiles
                s(i).FILENAME = filename(i, :);
                s(i).B = indep(1, i);
                s(i).E = indep(end, i);
                s(i).NPTS = size(dep, 1);
                s(i).NVHDR = 6;
                df = diff(diff(indep(:, i)));
                if ~any(df)
                    s(i).DELTA = diff(indep(1:2, i));
                    s(i).LEVEN = true;
                    if isreal(dep(:, i))
                        s(i).IFTYPE = 'ITIME';
                        s(i).DATA1 = dep(:, i);
                    else
                        s(i).IFTYPE = 'IRLIM';
                        s(i).DATA1 = real(dep(:, i));
                        s(i).DATA2 = imag(dep(:, i));
                    end
                else
                    s(i).LEVEN = false;                    
                    s(i).IFTYPE = 'IXY';
                    s(i).DATA1 = dep(:, i);
                    s(i).DATA2 = indep(:, i);
                end
            end
        end
    else
        indep1 = varargin{1};
        indep2 = varargin{2};
        dep = varargin{3};
        filename = varargin{4};
        if iscell(indep1)
            if ~iscell(indep2) || ~iscell(dep)
                error([' All independent and dependent variables ', ...
                    'should be cell arrays !!!'])
            end
            filename = cellstr(filename);
            nfiles = length(filename);
            s = sacstruct(nfiles);
            for i = 1:nfiles
                s(i).FILENAME = filename{i};
                s(i).B = 0;
                s(i).E = length(dep{i})-1;
                s(i).NPTS = length(dep{i});
                s(i).DELTA = 1;
                s(i).NVHDR = 6;
                s(i).LEVEN = true;
                s(i).XMINIMUM = indep1{i}(1);
                s(i).XMAXIMUM = indep1{i}(end);
                s(i).YMINIMUM = indep2{i}(1);
                s(i).YMAXIMUM = indep2{i}(end);
                s(i).NXSIZE = length(indep1{i});
                s(i).NYSIZE = length(indep2{i});
                s(i).IFTYPE = 'IXYZ';
                s(i).DATA1 = dep{i}(:);
            end
        else
            if iscell(indep2) || iscell(dep)
                error([' All independent and dependent variables ', ...
                    'should be vectors/matrices !!!'])
            end
            if numel(indep1) ~= length(indep1) || ...
                numel(indep2) ~= length(indep2)
                error(' X or Y must be a vector !!!')
            end
            dep = dep(:);
            filename = char(filename);
            s = sacstruct(1);
            s.FILENAME = filename;
            s.B = 0;
            s.E = length(dep)-1;
            s.NPTS = length(dep);
            s.DELTA = 1;
            s.NVHDR = 6;
            s.LEVEN = true;
            s.XMINIMUM = indep1(1);
            s.XMAXIMUM = indep1(end);
            s.YMINIMUM = indep2(1);
            s.YMAXIMUM = indep2(end);
            s.NXSIZE = length(indep1);
            s.NYSIZE = length(indep2);
            s.IFTYPE = 'IXYZ';
            s.DATA1 = dep;
        end
    end
else
    error(' Wrong number of input arguments !!!')
end

nfiles = length(s);
status = false(nfiles,1);

% write all files
for f = 1:nfiles
    fid = fopen(s(f).FILENAME, 'w');
    if fid ~= -1
        A = zeros(70,1);
        B = zeros(40,1);
        C = cell(24,1);
        A(1) = s(f).DELTA;
        A(2) = s(f).DEPMIN;
        A(3) = s(f).DEPMAX;
        A(4) = s(f).SCALE;
        A(5) = s(f).ODELTA;
        A(6) = s(f).B;
        A(7) = s(f).E;
        A(8) = s(f).O;
        A(9) = s(f).A;
        A(10) = s(f).INTERNAL1;
        A(11) = s(f).T0;
        A(12) = s(f).T1;
        A(13) = s(f).T2;
        A(14) = s(f).T3;
        A(15) = s(f).T4;
        A(16) = s(f).T5;
        A(17) = s(f).T6;
        A(18) = s(f).T7;
        A(19) = s(f).T8;
        A(20) = s(f).T9;
        A(21) = s(f).F;
        A(22) = s(f).RESP0;
        A(23) = s(f).RESP1;
        A(24) = s(f).RESP2;
        A(25) = s(f).RESP3;
        A(26) = s(f).RESP4;
        A(27) = s(f).RESP5;
        A(28) = s(f).RESP6;
        A(29) = s(f).RESP7;
        A(30) = s(f).RESP8;
        A(31) = s(f).RESP9;
        A(32) = s(f).STLA;
        A(33) = s(f).STLO;
        A(34) = s(f).STEL;
        A(35) = s(f).STDP;
        A(36) = s(f).EVLA;
        A(37) = s(f).EVLO;
        A(38) = s(f).EVEL;
        A(39) = s(f).EVDP;
        A(40) = s(f).MAG;
        A(41) = s(f).USER0;
        A(42) = s(f).USER1;
        A(43) = s(f).USER2;
        A(44) = s(f).USER3;
        A(45) = s(f).USER4;
        A(46) = s(f).USER5;
        A(47) = s(f).USER6;
        A(48) = s(f).USER7;
        A(49) = s(f).USER8;
        A(50) = s(f).USER9;
        A(51) = s(f).DIST;
        A(52) = s(f).AZ;
        A(53) = s(f).BAZ;
        A(54) = s(f).GCARC;
        A(55) = s(f).INTERNAL2;
        A(56) = s(f).INTERNAL3;
        A(57) = s(f).DEPMEN;
        A(58) = s(f).CMPAZ;
        A(59) = s(f).CMPINC;
        A(60) = s(f).XMINIMUM;
        A(61) = s(f).XMAXIMUM;
        A(62) = s(f).YMINIMUM;
        A(63) = s(f).YMAXIMUM;
        A(64) = s(f).UNUSED1;
        A(65) = s(f).UNUSED2;
        A(66) = s(f).UNUSED3;
        A(67) = s(f).UNUSED4;
        A(68) = s(f).UNUSED5;
        A(69) = s(f).UNUSED6;
        A(70) = s(f).UNUSED7;
        B(1) = s(f).NZYEAR;
        B(2) = s(f).NZJDAY;
        B(3) = s(f).NZHOUR;
        B(4) = s(f).NZMIN;
        B(5) = s(f).NZSEC;
        B(6) = s(f).NZMSEC;
        B(7) = 6;   % enforce a version number for later byte order check
        B(8) = s(f).NORID;
        B(9) = s(f).NEVID;
        B(10) = s(f).NPTS;
        B(11) = s(f).INTERNAL4;
        B(12) = s(f).NWFID;
        B(13) = s(f).NXSIZE;
        B(14) = s(f).NYSIZE;
        B(15) = s(f).UNUSED8;
        switch s(f).IFTYPE
            case 'ITIME', B(16) = 1;
            case 'IRLIM', B(16) = 2;
            case 'IAMPH', B(16) = 3;
            case 'IXY', B(16) = 4;
            case 'IXYZ', B(16) = 51;
            otherwise, B(16) = NaN;
        end
        switch s(f).IDEP
            case 'IUNKN', B(17) = 5;
            case 'IDISP', B(17) = 6;
            case 'IVEL', B(17) = 7;
            case 'IACC', B(17) = 8;
            case 'IVOLTS', B(17) = 50;
            otherwise, B(17) = NaN;
        end
        switch s(f).IZTYPE
            case 'IUNKN', B(18) = 5;
            case 'IB', B(18) = 9;
            case 'IDAY', B(18) = 10;
            case 'IO', B(18) = 11;
            case 'IA', B(18) = 12;
            case 'IT0', B(18) = 13;
            case 'IT1', B(18) = 14;
            case 'IT2', B(18) = 15;
            case 'IT3', B(18) = 16;
            case 'IT4', B(18) = 17;
            case 'IT5', B(18) = 18;
            case 'IT6', B(18) = 19;
            case 'IT7', B(18) = 20;
            case 'IT8', B(18) = 21;
            case 'IT9', B(18) = 22;
            otherwise, B(18) = NaN;
        end
        B(19) = s(f).UNUSED9;
        B(20) = s(f).IINST;
        B(21) = s(f).ISTREG;
        B(22) = s(f).IEVREG;
        switch s(f).IEVTYP
            case 'IUNKN', B(23) = 5;
            case 'INUCL', B(23) = 37;
            case 'IPREN', B(23) = 38;
            case 'IPOSTN', B(23) = 39;
            case 'IQUAKE', B(23) = 40;
            case 'IPREQ', B(23) = 41;
            case 'IPOSTQ', B(23) = 42;
            case 'ICHEM', B(23) = 43;
            case 'IOTHER', B(23) = 44;
            case 'IQB', B(23) = 70;
            case 'IQB1', B(23) = 71;
            case 'IQB2', B(23) = 72;
            case 'IQBX', B(23) = 73;
            case 'IQMT', B(23) = 74;
            case 'IEQ', B(23) = 75;
            case 'IEQ1', B(23) = 76;
            case 'IEQ2', B(23) = 77;
            case 'IME', B(23) = 78;
            case 'IEX', B(23) = 79;
            case 'INU', B(23) = 80;
            case 'INC', B(23) = 81;
            case 'IO_', B(23) = 82;
            case 'IL', B(23) = 83;
            case 'IR', B(23) = 84;
            case 'IT', B(23) = 85;
            case 'IU', B(23) = 86;
            otherwise, B(23) = NaN;
        end
        switch s(f).IQUAL
            case 'IOTHER', B(24) = 44;
            case 'IGOOD', B(24) = 45;
            case 'IGLCH', B(24) = 46;
            case 'IDROP', B(24) = 47;
            case 'ILOWSN', B(24) = 48;
            otherwise, B(24) = NaN;
        end
        switch s(f).ISYNTH
            case 'IRLDTA', B(25) = 49;
            otherwise, B(25) = NaN;
        end
        switch s(f).IMAGTYP
            case 'IMB', B(26) = 52;
            case 'IMS', B(26) = 53;
            case 'IML', B(26) = 54;
            case 'IMW', B(26) = 55;
            case 'IMD', B(26) = 56;
            case 'IMX', B(26) = 57;
            otherwise, B(26) = NaN;
        end
        switch s(f).IMAGSRC
            case 'INEIC', B(27) = 58;
            case 'IPDE', B(27) = 59;
            case 'IISC', B(27) = 60;
            case 'IREB', B(27) = 61;
            case 'IUSGS', B(27) = 62;
            case 'IBRK', B(27) = 63;
            case 'ICALTECH', B(27) = 64;
            case 'ILLNL', B(27) = 65;
            case 'IEVLOC', B(27) = 66;
            case 'IJSOP', B(27) = 67;
            case 'IUSER', B(27) = 68;
            case 'IUNKNOWN', B(27) = 69;
            otherwise, B(27) = NaN;
        end
        B(28) = s(f).UNUSED10;
        B(29) = s(f).UNUSED11;
        B(30) = s(f).UNUSED12;
        B(31) = s(f).UNUSED13;
        B(32) = s(f).UNUSED14;
        B(33) = s(f).UNUSED15;
        B(34) = s(f).UNUSED16;
        B(35) = s(f).UNUSED17;
        B(36) = double(s(f).LEVEN);
        B(37) = double(s(f).LPSPOL);
        B(38) = double(s(f).LOVROK);
        B(39) = double(s(f).LCALDA);
        B(40) = double(s(f).UNUSED18);
        C(1) = {s(f).KSTNM};
        if length(s(f).KEVNM) > 8
            C(2) = {s(f).KEVNM(1:8)};
            C(3) = {s(f).KEVNM(9:end)};
        else
            C(2) = {s(f).KEVNM};
            C(3) = {''};
        end
        C(4) = {s(f).KHOLE};
        C(5) = {s(f).KO};
        C(6) = {s(f).KA};
        C(7) = {s(f).KT0};
        C(8) = {s(f).KT1};
        C(9) = {s(f).KT2};
        C(10) = {s(f).KT3};
        C(11) = {s(f).KT4};
        C(12) = {s(f).KT5};
        C(13) = {s(f).KT6};
        C(14) = {s(f).KT7};
        C(15) = {s(f).KT8};
        C(16) = {s(f).KT9};
        C(17) = {s(f).KF};
        C(18) = {s(f).KUSER0};
        C(19) = {s(f).KUSER1};
        C(20) = {s(f).KUSER2};
        C(21) = {s(f).KCMPNM};
        C(22) = {s(f).KNETWK};
        C(23) = {s(f).KDATRD};
        C(24) = {s(f).KINST};
        A(isnan(A)) = -12345.0;
        B(isnan(B)) = -12345;
        C(strcmp('', C)) = {'-12345'};
        C = char([{'        '}; C]);
        C = C(2:end,:)';
        if size(C,1) ~= 8
            error([' Number of characters in some of K-header-variabl', ...
                'es in file ', s(f).FILENAME,' are larger than 8 !!!']);
        end
        clear count5
        count1 = fwrite(fid, A, 'float32');
        count2 = fwrite(fid, B, 'int32');
        count3 = fwrite(fid, C, 'char');
        count4 = fwrite(fid,s(f).DATA1, 'float32');
        if isfield(s(f), 'DATA2')
            count5 = fwrite(fid, s(f).DATA2, 'float32');
        end
        fclose(fid);
        if ~exist('count5', 'var') 
            if count1 == 70 && count2 == 40 && count3 == 192 && ...
                count4 == s(f).NPTS
                status(f) = true;
            end
        else
            if count1 == 70 && count2 == 40 && count3 == 192 && ...
                count4 == s(f).NPTS && count5 == s(f).NPTS
                status(f) = true;
            end
        end
    end
end

if nargout < 1
    clear status
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function s = sacstruct(n)
% S = SACSTRUCT(N); returns an Nx1 SAC structure with all fields
% initiated to their undefined (default) values. N defaults to 1. 
%

%	Xiaoning Yang 2008 (modified from subfunction init_sac of readsac.m
%   in the MATSEIS package)

% check arguments.
if (nargin < 1)
    n = 1;
end

% initialize output structure.
sacfields = {'FILENAME'; 'DELTA'; 'DEPMIN'; 'DEPMAX'; 'SCALE'; ...
    'ODELTA'; 'B'; 'E'; 'O'; 'A'; 'INTERNAL1'; 'T0'; 'T1'; 'T2'; 'T3'; ...
    'T4'; 'T5'; 'T6'; 'T7'; 'T8'; 'T9'; 'F'; 'RESP0'; 'RESP1'; 'RESP2'; ...
    'RESP3'; 'RESP4'; 'RESP5'; 'RESP6'; 'RESP7'; 'RESP8'; 'RESP9'; ...
    'STLA'; 'STLO'; 'STEL'; 'STDP'; 'EVLA'; 'EVLO'; 'EVEL'; 'EVDP'; ...
    'MAG'; 'USER0'; 'USER1'; 'USER2'; 'USER3'; 'USER4'; 'USER5'; ...
    'USER6'; 'USER7'; 'USER8'; 'USER9'; 'DIST'; 'AZ'; 'BAZ'; 'GCARC'; ...
    'INTERNAL2'; 'INTERNAL3'; 'DEPMEN'; 'CMPAZ'; 'CMPINC'; 'XMINIMUM'; ...
    'XMAXIMUM'; 'YMINIMUM'; 'YMAXIMUM'; 'UNUSED1'; 'UNUSED2'; ...
    'UNUSED3'; 'UNUSED4'; 'UNUSED5'; 'UNUSED6'; 'UNUSED7'; 'NZYEAR'; ...
    'NZJDAY'; 'NZHOUR'; 'NZMIN'; 'NZSEC'; 'NZMSEC'; 'NVHDR'; 'NORID'; ...
    'NEVID'; 'NPTS'; 'INTERNAL4'; 'NWFID'; 'NXSIZE'; 'NYSIZE'; ...
    'UNUSED8'; 'IFTYPE'; 'IDEP'; 'IZTYPE'; 'UNUSED9'; 'IINST'; ...
    'ISTREG'; 'IEVREG'; 'IEVTYP'; 'IQUAL'; 'ISYNTH'; 'IMAGTYP'; ...
    'IMAGSRC'; 'UNUSED10'; 'UNUSED11'; 'UNUSED12'; 'UNUSED13'; ...
    'UNUSED14'; 'UNUSED15'; 'UNUSED16'; 'UNUSED17'; 'LEVEN'; 'LPSPOL'; ...
    'LOVROK'; 'LCALDA'; 'UNUSED18'; 'KSTNM'; 'KEVNM'; 'KHOLE'; 'KO'; ...
    'KA'; 'KT0'; 'KT1'; 'KT2'; 'KT3'; 'KT4'; 'KT5'; 'KT6'; 'KT7'; ...
    'KT8'; 'KT9'; 'KF'; 'KUSER0'; 'KUSER1'; 'KUSER2'; 'KCMPNM'; ...
    'KNETWK'; 'KDATRD'; 'KINST'; 'DATA1';};

cl = cell(size(sacfields,1),n);
cl(2:111, :) = {nan};
cl(112:end-1, :) = {' '};
s = cell2struct(cl, sacfields, 1);

